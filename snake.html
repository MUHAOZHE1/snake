<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ğŸŒ­ è…Šè‚ ç‹—è¦è¦çš„å¤§å†’é™©</title>
<style>
  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    touch-action: none;
  }
  
  html {
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  
  body {
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    color: white;
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  
  /* èƒŒæ™¯åŠ¨ç”» */
  .bg-animation {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: 0;
    pointer-events: none;
  }
  
  .bg-bubble {
    position: absolute;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    animation: float-up 20s infinite;
  }
  
  @keyframes float-up {
    0% {
      transform: translateY(100vh) scale(0);
      opacity: 0;
    }
    10% {
      opacity: 0.5;
    }
    90% {
      opacity: 0.5;
    }
    100% {
      transform: translateY(-100vh) scale(1.5);
      opacity: 0;
    }
  }
  
  .game-wrapper {
    position: relative;
    z-index: 1;
    width: 100%;
    max-width: 700px;
    padding: 10px;
    display: none; /* åˆå§‹éšè— */
    height: 100vh;
    overflow: hidden;
  }
  
  .game-wrapper.active {
    display: block !important;
  }
  
  /* æ¸¸æˆå¼€å§‹åæ˜¾ç¤ºå®¹å™¨ */
  body.game-started .game-wrapper {
    display: block !important;
  }
  
  .game-container {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 15px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  }
  
  .game-header {
    text-align: center;
    margin-bottom: 15px;
  }
  
  h1 {
    font-size: clamp(1.5rem, 5vw, 2.5rem);
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    background: linear-gradient(45deg, #ffd89b, #19547b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: glow 2s ease-in-out infinite;
  }
  
  @keyframes glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
  }
  
  .game-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 10px;
    margin-bottom: 15px;
  }
  
  .stat-card {
    background: rgba(255, 255, 255, 0.2);
    padding: 8px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  
  .stat-card::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
  }
  
  .stat-card:hover::before {
    animation: shine 0.5s;
  }
  
  @keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
  }
  
  .stat-label {
    font-size: 0.8rem;
    opacity: 0.9;
  }
  
  .stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: #ffd89b;
  }
  
  .canvas-container {
    position: relative;
    width: 100%;
    aspect-ratio: 1;
    max-height: 60vh;
    margin: 0 auto;
  }
  
  canvas {
    width: 100%;
    height: 100%;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    background: #2a2a3e;
    display: block;
  }
  
  /* è™šæ‹Ÿæ§åˆ¶å™¨ */
  .mobile-controls {
    display: none; /* é»˜è®¤éšè— */
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
  }
  
  .control-pad {
    width: 150px;
    height: 150px;
    position: relative;
  }
  
  .control-btn {
    position: absolute;
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: all 0.2s;
  }
  
  .control-btn:active {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(0.95);
  }
  
  .control-up { top: 0; left: 50px; }
  .control-down { bottom: 0; left: 50px; }
  .control-left { left: 0; top: 50px; }
  .control-right { right: 0; top: 50px; }
  .control-center { 
    top: 50px; 
    left: 50px; 
    background: rgba(255, 215, 0, 0.3);
  }
  
  /* æ‰‹åŠ¿æç¤º */
  .gesture-hint {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    opacity: 0;
    pointer-events: none;
    animation: gesture-show 0.5s;
  }
  
  @keyframes gesture-show {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
  }
  
  /* èœå•æ ·å¼ */
  .menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #667eea, #764ba2);
    padding: 20px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    z-index: 1000;
    max-width: 90%;
    width: 400px;
    max-height: 85vh;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒåŠŸèƒ½ */
  .menu::-webkit-scrollbar {
    width: 0px;
    background: transparent;
  }
  
  .menu {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  
  .menu h2 {
    margin-bottom: 15px;
    font-size: clamp(1.3rem, 3.5vw, 1.8rem);
    color: #ffd89b;
  }
  
  .game-modes {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin: 15px 0;
  }
  
  .mode-card {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    border: 2px solid transparent;
  }
  
  .mode-card:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
  }
  
  .mode-card.selected {
    border-color: #ffd89b;
    background: rgba(255, 215, 0, 0.2);
  }
  
  .mode-icon {
    font-size: 1.5rem;
    margin-bottom: 3px;
  }
  
  .mode-name {
    font-weight: bold;
    margin-bottom: 2px;
    font-size: 0.9rem;
  }
  
  .mode-desc {
    font-size: 0.7rem;
    opacity: 0.8;
  }
  
  button {
    background: linear-gradient(45deg, #ffd89b, #19547b);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 0.95rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    width: 100%;
  }
  
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  .difficulty-selector {
    margin: 10px 0;
  }
  
  select {
    width: 100%;
    padding: 8px;
    border-radius: 10px;
    border: none;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    font-size: 0.9rem;
    cursor: pointer;
  }
  
  /* è¿å‡»ç³»ç»Ÿ */
  .combo-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    font-weight: bold;
    color: #ffd89b;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    opacity: 0;
    pointer-events: none;
    z-index: 500;
  }
  
  .combo-display.show {
    animation: combo-pop 0.5s;
  }
  
  @keyframes combo-pop {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
  }
  
  /* é“å…·æ  */
  .power-up-bar {
    position: fixed;
    bottom: 180px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(10px);
    padding: 10px;
    border-radius: 15px;
    display: flex;
    gap: 10px;
    z-index: 50;
  }
  
  .power-up-slot {
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    position: relative;
  }
  
  .power-up-slot.active {
    animation: pulse 1s infinite;
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  .power-timer {
    position: absolute;
    bottom: 2px;
    right: 2px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 0.7rem;
    padding: 2px 4px;
    border-radius: 3px;
  }
  
  /* æˆå°±å¼¹çª— */
  .achievement-popup {
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #f093fb, #f5576c);
    padding: 15px 25px;
    border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    animation: slideIn 0.5s, slideOut 0.5s 2.5s;
    z-index: 3000;
  }
  
  @keyframes slideIn {
    from { transform: translateX(400px); }
    to { transform: translateX(0); }
  }
  
  @keyframes slideOut {
    from { transform: translateX(0); }
    to { transform: translateX(400px); }
  }
  
  /* ç²’å­æ•ˆæœ */
  .particle {
    position: fixed;
    pointer-events: none;
    z-index: 2000;
    font-size: 20px;
  }
  
  @keyframes particle-float {
    0% { 
      opacity: 1; 
      transform: translate(0, 0) scale(1);
    }
    100% { 
      opacity: 0; 
      transform: translate(var(--dx), var(--dy)) scale(0.5);
    }
  }
  
  /* æ’è¡Œæ¦œ */
  .leaderboard {
    margin: 10px 0;
    max-height: 150px;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  .leaderboard::-webkit-scrollbar {
    width: 3px;
  }
  
  .leaderboard::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
  }
  
  .leaderboard::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
  }
  
  .leaderboard-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    margin: 3px 0;
    font-size: 0.85rem;
  }
  
  .leaderboard-rank {
    font-weight: bold;
    color: #ffd89b;
    min-width: 30px;
  }
  
  .leaderboard-name {
    flex: 1;
    margin: 0 10px;
  }
  
  .leaderboard-score {
    font-weight: bold;
  }
  
  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 768px) and (orientation: portrait) {
    .mobile-controls {
      display: none; /* é»˜è®¤éšè—ï¼Œç”±JSæ§åˆ¶æ˜¾ç¤º */
    }
    
    .game-stats {
      grid-template-columns: repeat(2, 1fr);
    }
    
    .canvas-container {
      max-height: 50vh;
    }
    
    .menu {
      padding: 15px;
      max-height: 90vh;
    }
    
    .mode-card {
      padding: 8px;
    }
    
    .mode-icon {
      font-size: 1.3rem;
    }
    
    button {
      padding: 8px 15px;
      font-size: 0.9rem;
    }
  }
  
  @media (max-width: 480px) {
    .game-container {
      padding: 10px;
    }
    
    h1 {
      font-size: 1.2rem;
    }
    
    .stat-card {
      padding: 5px;
    }
    
    .menu h2 {
      font-size: 1.2rem;
    }
    
    #photoFrame {
      width: 80px;
      height: 80px;
    }
    
    #photoFrame > div {
      font-size: 2rem;
    }
  }
  
  .hidden {
    display: none !important;
  }
  
  /* åŠ è½½åŠ¨ç”» */
  .loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    animation: rotate 1s linear infinite;
  }
  
  @keyframes rotate {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }
</style>
</head>
<body>

<!-- åŠ è½½æç¤º -->
<div class="loading" id="loadingScreen">ğŸŒ­</div>

<!-- èƒŒæ™¯åŠ¨ç”» -->
<div class="bg-animation" id="bgAnimation"></div>

<!-- æ¸¸æˆä¸»å®¹å™¨ -->
<div class="game-wrapper">
  <div class="game-container">
    <div class="game-header">
      <h1>ğŸŒ­ è…Šè‚ ç‹—è¦è¦çš„å¤§å†’é™©</h1>
    </div>
    
    <div class="game-stats">
      <div class="stat-card">
        <div class="stat-label">åˆ†æ•°</div>
        <div class="stat-value" id="score">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">é•¿åº¦</div>
        <div class="stat-value" id="length">3</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">è¿å‡»</div>
        <div class="stat-value" id="combo">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">ç­‰çº§</div>
        <div class="stat-value" id="level">1</div>
      </div>
    </div>
    
    <div class="canvas-container">
      <canvas id="gameCanvas"></canvas>
      <div class="gesture-hint" id="gestureHint"></div>
    </div>
  </div>
</div>

<!-- è™šæ‹Ÿæ§åˆ¶å™¨ -->
<div class="mobile-controls" id="mobileControls">
  <div class="control-pad">
    <div class="control-btn control-up" data-dir="up">â¬†ï¸</div>
    <div class="control-btn control-down" data-dir="down">â¬‡ï¸</div>
    <div class="control-btn control-left" data-dir="left">â¬…ï¸</div>
    <div class="control-btn control-right" data-dir="right">â¡ï¸</div>
    <div class="control-btn control-center" data-dir="pause">â¸ï¸</div>
  </div>
</div>

<!-- é“å…·æ  -->
<div class="power-up-bar hidden" id="powerUpBar"></div>

<!-- è¿å‡»æ˜¾ç¤º -->
<div class="combo-display" id="comboDisplay"></div>

<!-- ä¸»èœå• -->
<div id="mainMenu" class="menu">
  <!-- ç…§ç‰‡å±•ç¤ºåŒº -->
  <div style="margin-bottom: 15px; position: relative;">
    <div id="photoFrame" style="
      width: 100px;
      height: 100px;
      margin: 0 auto 10px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
      background: linear-gradient(135deg, #ff6b9d, #feca57);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    ">
      <!-- è¿™é‡Œå¯ä»¥æ”¾ç…§ç‰‡ - è¯·å°† YOUR_PHOTO_URL æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡é“¾æ¥ -->
      <!-- <img src="YOUR_PHOTO_URL" style="width: 100%; height: 100%; object-fit: cover;" /> -->
      <div style="font-size: 2.5rem;">ğŸ’•</div>
    </div>
    <!-- è£…é¥°çˆ±å¿ƒ -->
    <span class="photo-decoration" style="top: -5px; left: 15px; font-size: 1rem;">ğŸ’–</span>
    <span class="photo-decoration" style="top: -5px; right: 15px; font-size: 1rem;">ğŸ’</span>
    <span class="photo-decoration" style="bottom: -5px; left: 20px; font-size: 1rem;">ğŸ’—</span>
    <span class="photo-decoration" style="bottom: -5px; right: 20px; font-size: 1rem;">ğŸ’•</span>
    <div style="
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      animation: float 2s ease-in-out infinite;
    ">
      <span style="font-size: 1.3rem;">ğŸ‘‘</span>
    </div>
  </div>
  
  <h2 style="font-size: 1.5rem; margin-bottom: 10px;">ğŸŒ­ è…Šè‚ ç‹—è¦è¦</h2>
  <p id="welcomeMessage" style="color: #ff6b9d; font-weight: bold; font-size: 0.9rem; margin-bottom: 10px;">ä¸ºæœ€ç‰¹åˆ«çš„ä½ å‡†å¤‡çš„æ¸¸æˆ ğŸ’•</p>
  
  <div class="game-modes">
    <div class="mode-card" data-mode="classic" onclick="selectMode('classic')">
      <div class="mode-icon">ğŸ®</div>
      <div class="mode-name">ç»å…¸æ¨¡å¼</div>
      <div class="mode-desc">ä¼ ç»Ÿè´ªåƒè›‡ç©æ³•</div>
    </div>
    <div class="mode-card" data-mode="love" onclick="selectMode('love')" style="background: linear-gradient(135deg, #ff6b6b, #ff8e53);">
      <div class="mode-icon">ğŸ’•</div>
      <div class="mode-name">çˆ±å¿ƒæ¨¡å¼</div>
      <div class="mode-desc">ä¸ºä½ ç‰¹åˆ¶</div>
    </div>
    <div class="mode-card" data-mode="adventure" onclick="selectMode('adventure')">
      <div class="mode-icon">ğŸ—ºï¸</div>
      <div class="mode-name">å†’é™©æ¨¡å¼</div>
      <div class="mode-desc">å…³å¡æŒ‘æˆ˜</div>
    </div>
    <div class="mode-card" data-mode="survival" onclick="selectMode('survival')">
      <div class="mode-icon">âš”ï¸</div>
      <div class="mode-name">ç”Ÿå­˜æ¨¡å¼</div>
      <div class="mode-desc">æ— å°½æŒ‘æˆ˜</div>
    </div>
  </div>
  
  <div class="difficulty-selector" style="margin: 10px 0;">
    <label style="font-size: 0.9rem;">éš¾åº¦é€‰æ‹©</label>
    <select id="difficulty" style="width: 100%; padding: 8px; margin-top: 5px;">
      <option value="easy">ğŸ˜Š ç®€å• - é€‚åˆæ–°æ‰‹</option>
      <option value="normal" selected>ğŸ® æ™®é€š - å¹³è¡¡ä½“éªŒ</option>
      <option value="hard">ğŸ”¥ å›°éš¾ - æŒ‘æˆ˜è‡ªæˆ‘</option>
      <option value="crazy">ğŸ’€ ç–¯ç‹‚ - æé™æ“ä½œ</option>
    </select>
  </div>
  
  <div style="display: grid; gap: 8px;">
    <button onclick="startGame()" style="padding: 10px 20px;">ğŸ® å¼€å§‹æ¸¸æˆ</button>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
      <button onclick="showLeaderboard()" style="padding: 8px;">ğŸ† æ’è¡Œæ¦œ</button>
      <button onclick="toggleSound()" id="soundBtn" style="padding: 8px;">ğŸ”Š éŸ³æ•ˆ</button>
    </div>
    <button onclick="showHelp()" style="padding: 8px;">â“ æ¸¸æˆå¸®åŠ©</button>
  </div>
  
  <div class="leaderboard hidden" id="leaderboard"></div>
</div>

<!-- æ¸¸æˆç»“æŸç•Œé¢ -->
<div id="gameOverlay" class="menu hidden">
  <h2 id="gameOverTitle" style="font-size: 1.5rem;">æ¸¸æˆç»“æŸï¼</h2>
  <p id="gameOverMessage" style="font-size: 0.9rem;">è¦è¦åƒå¾—å¤ªé¥±å•¦ï¼</p>
  
  <div style="margin: 15px 0;">
    <div style="font-size: 2.5rem; margin: 8px 0;" id="finalEmoji">ğŸŒ­</div>
    <div style="font-size: 1.3rem; font-weight: bold; color: #ffd89b;">
      å¾—åˆ†: <span id="finalScore">0</span>
    </div>
    <div style="font-size: 0.9rem;">é•¿åº¦: <span id="finalLength">0</span> | è¿å‡»: <span id="maxCombo">0</span></div>
  </div>
  
  <div id="newRecord" class="hidden" style="color: #ffd89b; font-weight: bold; margin: 8px 0; font-size: 0.9rem;">
    ğŸ‰ æ–°çºªå½•ï¼
  </div>
  
  <div style="display: grid; gap: 8px;">
    <button onclick="restartGame()">ğŸ”„ å†æ¥ä¸€å±€</button>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
      <button onclick="backToMenu()" style="padding: 8px;">ğŸ“‹ è¿”å›</button>
      <button onclick="shareScore()" style="padding: 8px;">ğŸ“± åˆ†äº«</button>
    </div>
  </div>
</div>

<script>
// ==================== æ¸¸æˆé…ç½® ====================
const GRID_SIZE = 20;
const GAME_MODES = {
  classic: { 
    name: 'ç»å…¸æ¨¡å¼', 
    obstacles: false, 
    powerUps: true,
    timeLimit: 0
  },
  adventure: { 
    name: 'å†’é™©æ¨¡å¼', 
    obstacles: true, 
    powerUps: true,
    levels: true,
    timeLimit: 0
  },
  survival: { 
    name: 'ç”Ÿå­˜æ¨¡å¼', 
    obstacles: true, 
    powerUps: true,
    speedIncrease: true,
    timeLimit: 0
  },
  zen: { 
    name: 'ç¦…æ¨¡å¼', 
    obstacles: false, 
    powerUps: false,
    noGameOver: true,
    timeLimit: 0
  },
  love: {
    name: 'ğŸ’• çˆ±å¿ƒæ¨¡å¼',
    obstacles: false,
    powerUps: true,
    special: true,
    loveTheme: true,
    timeLimit: 0
  }
};

const DIFFICULTY_SETTINGS = {
  easy: { speed: 200, scoreMultiplier: 0.8, foodCount: 3 },
  normal: { speed: 150, scoreMultiplier: 1, foodCount: 2 },
  hard: { speed: 100, scoreMultiplier: 1.5, foodCount: 1 },
  crazy: { speed: 70, scoreMultiplier: 2, foodCount: 1 }
};

// ==================== æ¸¸æˆçŠ¶æ€ ====================
let game = {
  canvas: null,
  ctx: null,
  cellSize: 30,
  snake: [],
  direction: { x: 1, y: 0 },
  nextDirection: { x: 1, y: 0 },
  foods: [],
  specialFoods: [],
  powerUps: [],
  obstacles: [],
  score: 0,
  level: 1,
  length: 3,
  combo: 0,
  maxCombo: 0,
  lastEatTime: 0,
  speed: 150,
  gameRunning: false,
  gamePaused: false,
  soundEnabled: true,
  difficulty: 'normal',
  mode: 'classic',
  highScores: JSON.parse(localStorage.getItem('yaoyaoHighScores')) || {},
  powerUpEffects: {
    speed: { active: false, endTime: 0 },
    shield: { active: false, endTime: 0 },
    slow: { active: false, endTime: 0 },
    magnet: { active: false, endTime: 0 },
    double: { active: false, endTime: 0 }
  },
  particles: [],
  animations: [],
  touchStartPos: null,
  lastUpdateTime: 0,
  fps: 0,
  loveMessages: [
    "ä½ çœŸæ£’ï¼ğŸ’•",
    "ç»§ç»­åŠ æ²¹å“¦ï¼ğŸŒŸ", 
    "è¦è¦ä¸ºä½ éª„å‚²ï¼ğŸŒ­",
    "ä½ æ˜¯æœ€å¯çˆ±çš„ï¼âœ¨",
    "è¶…çº§å‰å®³ï¼ğŸ’–",
    "å®Œç¾è¡¨ç°ï¼ğŸ‰",
    "ä½ åšåˆ°äº†ï¼ğŸŒˆ",
    "å¤ªä¼˜ç§€äº†ï¼ğŸ’«",
    "è¦è¦çˆ±ä½ ï¼â¤ï¸",
    "ä½ æ˜¯æœ€æ£’çš„ï¼ğŸ†"
  ],
  specialDates: {
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ç‰¹æ®Šæ—¥æœŸ
    "02-14": "æƒ…äººèŠ‚å¿«ä¹ï¼ğŸ’",
    "03-08": "å¥³ç¥èŠ‚å¿«ä¹ï¼ğŸ‘‘",
    "05-20": "520 æˆ‘çˆ±ä½ ï¼ğŸ’•",
    "12-25": "åœ£è¯å¿«ä¹ï¼ğŸ„"
  }
};

// ==================== éŸ³é¢‘ç³»ç»Ÿ ====================
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioContext = null;

function initAudio() {
  if (!audioContext && game.soundEnabled) {
    audioContext = new AudioContext();
  }
}

function playSound(frequency, duration, type = 'sine', volume = 0.3) {
  if (!game.soundEnabled || !audioContext) return;
  
  try {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.value = frequency;
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  } catch (e) {
    console.log('Audio error:', e);
  }
}

// æŒ¯åŠ¨åé¦ˆ
function vibrate(duration = 20) {
  if ('vibrate' in navigator && game.soundEnabled) {
    navigator.vibrate(duration);
  }
}

// éŸ³æ•ˆé›†åˆ
const sounds = {
  eat: () => {
    playSound(523, 0.1);
    vibrate(10);
  },
  specialEat: () => {
    playSound(659, 0.15, 'square');
    vibrate(30);
  },
  powerUp: () => {
    playSound(784, 0.2, 'triangle');
    vibrate(50);
  },
  combo: (level) => {
    playSound(440 + level * 50, 0.1, 'sine', 0.2 + level * 0.05);
    vibrate(20 + level * 5);
  },
  gameOver: () => {
    playSound(196, 0.5, 'sawtooth');
    vibrate([100, 50, 100]);
  },
  levelUp: () => {
    playSound(523, 0.1);
    setTimeout(() => playSound(659, 0.1), 100);
    setTimeout(() => playSound(784, 0.1), 200);
    vibrate([50, 50, 50]);
  },
  click: () => {
    playSound(400, 0.05, 'square', 0.1);
    vibrate(5);
  }
};

// ==================== åˆå§‹åŒ– ====================
function init() {
  game.canvas = document.getElementById('gameCanvas');
  game.ctx = game.canvas.getContext('2d');
  
  // éšè—åŠ è½½ç”»é¢
  const loadingScreen = document.getElementById('loadingScreen');
  if (loadingScreen) {
    setTimeout(() => {
      loadingScreen.style.display = 'none';
    }, 500);
  }
  
  // åˆå§‹åŒ–æ—¶ç¡®ä¿æ¸¸æˆç•Œé¢éšè—ï¼Œèœå•æ˜¾ç¤º
  document.querySelector('.game-wrapper').classList.remove('active');
  document.getElementById('mainMenu').classList.remove('hidden');
  document.getElementById('mobileControls').style.display = 'none';
  
  // è®¾ç½®ç”»å¸ƒå¤§å°
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  // åˆå§‹åŒ–èƒŒæ™¯åŠ¨ç”»
  createBackgroundBubbles();
  
  // åˆ›å»ºæ¬¢è¿çˆ±å¿ƒé›¨
  createWelcomeHearts();
  
  // åˆå§‹åŒ–è§¦æ§
  initTouchControls();
  
  // åˆå§‹åŒ–é”®ç›˜æ§åˆ¶
  initKeyboardControls();
  
  // åˆå§‹åŒ–è™šæ‹ŸæŒ‰é”®
  initVirtualControls();
  
  // é˜»æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
  
  // åŠ è½½é«˜åˆ†
  loadHighScores();
  
  // åˆå§‹åŒ–éŸ³é¢‘
  document.addEventListener('click', initAudio, { once: true });
  document.addEventListener('touchstart', initAudio, { once: true });
}

function resizeCanvas() {
  const container = document.querySelector('.canvas-container');
  if (!container || !document.querySelector('.game-wrapper').classList.contains('active')) {
    // å¦‚æœæ¸¸æˆç•Œé¢æœªæ¿€æ´»ï¼Œè®¾ç½®é»˜è®¤å¤§å°
    game.canvas.width = 600;
    game.canvas.height = 600;
    game.cellSize = 30;
    return;
  }
  
  const size = Math.min(container.clientWidth, container.clientHeight);
  
  game.canvas.width = size;
  game.canvas.height = size;
  game.cellSize = size / GRID_SIZE;
}

// ==================== èƒŒæ™¯åŠ¨ç”» ====================
function createBackgroundBubbles() {
  const bgAnimation = document.getElementById('bgAnimation');
  bgAnimation.innerHTML = '';
  
  for (let i = 0; i < 10; i++) {
    const bubble = document.createElement('div');
    bubble.className = 'bg-bubble';
    bubble.style.width = bubble.style.height = Math.random() * 100 + 50 + 'px';
    bubble.style.left = Math.random() * 100 + '%';
    bubble.style.animationDelay = Math.random() * 20 + 's';
    bubble.style.animationDuration = (15 + Math.random() * 10) + 's';
    bgAnimation.appendChild(bubble);
  }
}

// åˆ›å»ºæ¬¢è¿çˆ±å¿ƒé›¨æ•ˆæœ
function createWelcomeHearts() {
  for (let i = 0; i < 10; i++) {
    setTimeout(() => {
      const heart = document.createElement('div');
      heart.className = 'particle';
      heart.textContent = ['ğŸ’•', 'ğŸ’–', 'ğŸ’—', 'ğŸ’', 'â¤ï¸'][Math.floor(Math.random() * 5)];
      heart.style.position = 'fixed';
      heart.style.left = Math.random() * window.innerWidth + 'px';
      heart.style.top = '-50px';
      heart.style.fontSize = (15 + Math.random() * 15) + 'px';
      heart.style.animation = `fall ${3 + Math.random() * 2}s linear`;
      heart.style.pointerEvents = 'none';
      heart.style.zIndex = '10';
      document.body.appendChild(heart);
      
      setTimeout(() => heart.remove(), 5000);
    }, i * 200);
  }
}

// ==================== æ¸¸æˆé€»è¾‘ ====================
function initGame() {
  // ç¡®ä¿ç”»å¸ƒå¤§å°æ­£ç¡®
  resizeCanvas();
  
  // é‡ç½®æ¸¸æˆçŠ¶æ€
  game.snake = [
    { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) },
    { x: Math.floor(GRID_SIZE / 2) - 1, y: Math.floor(GRID_SIZE / 2) },
    { x: Math.floor(GRID_SIZE / 2) - 2, y: Math.floor(GRID_SIZE / 2) }
  ];
  game.direction = { x: 1, y: 0 };
  game.nextDirection = { x: 1, y: 0 };
  game.score = 0;
  game.level = 1;
  game.length = 3;
  game.combo = 0;
  game.maxCombo = 0;
  game.foods = [];
  game.specialFoods = [];
  game.powerUps = [];
  game.obstacles = [];
  game.particles = [];
  game.animations = [];
  game.lastEatTime = Date.now();
  
  // é‡ç½®é“å…·æ•ˆæœ
  Object.keys(game.powerUpEffects).forEach(key => {
    game.powerUpEffects[key] = { active: false, endTime: 0 };
  });
  
  // è®¾ç½®éš¾åº¦
  const settings = DIFFICULTY_SETTINGS[game.difficulty];
  game.speed = settings.speed;
  
  // ç”Ÿæˆåˆå§‹é£Ÿç‰©
  for (let i = 0; i < settings.foodCount; i++) {
    generateFood();
  }
  
  // ç”Ÿæˆéšœç¢ç‰©ï¼ˆå†’é™©å’Œç”Ÿå­˜æ¨¡å¼ï¼‰
  if (GAME_MODES[game.mode].obstacles) {
    generateObstacles();
  }
  
  updateUI();
  updatePowerUpBar();
}

function generateFood() {
  let food;
  const isLoveMode = game.mode === 'love';
  
  do {
    food = {
      x: Math.floor(Math.random() * GRID_SIZE),
      y: Math.floor(Math.random() * GRID_SIZE),
      type: 'normal',
      emoji: isLoveMode ? (Math.random() > 0.5 ? 'â¤ï¸' : 'ğŸ’•') : 'ğŸ–'
    };
  } while (isOccupied(food.x, food.y));
  
  game.foods.push(food);
}

function generateSpecialFood() {
  const isLoveMode = game.mode === 'love';
  
  if (Math.random() > 0.7 && game.specialFoods.length < 2) {
    const types = isLoveMode ? [
      { emoji: 'ğŸ’–', points: 50 },
      { emoji: 'ğŸ’', points: 40 },
      { emoji: 'ğŸ’—', points: 30 },
      { emoji: 'ğŸŒ¹', points: 60 }
    ] : [
      { emoji: 'ğŸ—', points: 30 },
      { emoji: 'ğŸŒ®', points: 50 },
      { emoji: 'ğŸ•', points: 40 },
      { emoji: 'ğŸ¦´', points: 20 }
    ];
    
    const type = types[Math.floor(Math.random() * types.length)];
    let food;
    
    do {
      food = {
        x: Math.floor(Math.random() * GRID_SIZE),
        y: Math.floor(Math.random() * GRID_SIZE),
        ...type,
        timer: 150
      };
    } while (isOccupied(food.x, food.y));
    
    game.specialFoods.push(food);
  }
}

function generatePowerUp() {
  if (Math.random() > 0.95 && game.powerUps.length < 2 && GAME_MODES[game.mode].powerUps) {
    const types = [
      { type: 'speed', emoji: 'âš¡', color: '#FFD700' },
      { type: 'shield', emoji: 'ğŸ›¡ï¸', color: '#4169E1' },
      { type: 'slow', emoji: 'â„ï¸', color: '#00CED1' },
      { type: 'magnet', emoji: 'ğŸ§²', color: '#DC143C' },
      { type: 'double', emoji: 'âœ¨', color: '#FF69B4' }
    ];
    
    const powerUp = types[Math.floor(Math.random() * types.length)];
    
    do {
      powerUp.x = Math.floor(Math.random() * GRID_SIZE);
      powerUp.y = Math.floor(Math.random() * GRID_SIZE);
      powerUp.timer = 200;
    } while (isOccupied(powerUp.x, powerUp.y));
    
    game.powerUps.push(powerUp);
  }
}

function generateObstacles() {
  const count = Math.min(game.level * 2, 10);
  game.obstacles = [];
  
  for (let i = 0; i < count; i++) {
    let obstacle;
    do {
      obstacle = {
        x: Math.floor(Math.random() * GRID_SIZE),
        y: Math.floor(Math.random() * GRID_SIZE)
      };
    } while (isOccupied(obstacle.x, obstacle.y) || isNearSnake(obstacle.x, obstacle.y, 3));
    
    game.obstacles.push(obstacle);
  }
}

function isOccupied(x, y) {
  return isSnakePosition(x, y) ||
         game.foods.some(f => f.x === x && f.y === y) ||
         game.specialFoods.some(f => f.x === x && f.y === y) ||
         game.powerUps.some(p => p.x === x && p.y === y) ||
         game.obstacles.some(o => o.x === x && o.y === y);
}

function isSnakePosition(x, y) {
  return game.snake.some(segment => segment.x === x && segment.y === y);
}

function isNearSnake(x, y, distance) {
  const head = game.snake[0];
  return Math.abs(head.x - x) <= distance && Math.abs(head.y - y) <= distance;
}

// ==================== æ¸¸æˆæ›´æ–° ====================
function updateGame() {
  if (!game.gameRunning || game.gamePaused) return;
  
  // æ›´æ–°æ–¹å‘
  game.direction = game.nextDirection;
  
  // è®¡ç®—æ–°å¤´éƒ¨ä½ç½®
  const head = { ...game.snake[0] };
  head.x += game.direction.x;
  head.y += game.direction.y;
  
  // è¾¹ç•Œæ£€æŸ¥
  if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
    if (!game.powerUpEffects.shield.active && !GAME_MODES[game.mode].noGameOver) {
      gameOver();
      return;
    } else {
      // æŠ¤ç›¾æˆ–ç¦…æ¨¡å¼ï¼šç©¿å¢™
      head.x = (head.x + GRID_SIZE) % GRID_SIZE;
      head.y = (head.y + GRID_SIZE) % GRID_SIZE;
    }
  }
  
  // è‡ªèº«ç¢°æ’æ£€æŸ¥
  if (isSnakePosition(head.x, head.y) && !GAME_MODES[game.mode].noGameOver) {
    if (!game.powerUpEffects.shield.active) {
      gameOver();
      return;
    }
  }
  
  // éšœç¢ç‰©ç¢°æ’æ£€æŸ¥
  if (game.obstacles.some(o => o.x === head.x && o.y === head.y)) {
    if (!game.powerUpEffects.shield.active && !GAME_MODES[game.mode].noGameOver) {
      gameOver();
      return;
    }
  }
  
  // æ·»åŠ æ–°å¤´éƒ¨
  game.snake.unshift(head);
  
  // æ£€æŸ¥é£Ÿç‰©æ”¶é›†
  let ateFood = false;
  game.foods = game.foods.filter(food => {
    if (head.x === food.x && head.y === food.y || 
        (game.powerUpEffects.magnet.active && Math.abs(head.x - food.x) <= 1 && Math.abs(head.y - food.y) <= 1)) {
      ateFood = true;
      collectFood(food, head);
      return false;
    }
    return true;
  });
  
  // æ£€æŸ¥ç‰¹æ®Šé£Ÿç‰©
  game.specialFoods = game.specialFoods.filter(food => {
    if (head.x === food.x && head.y === food.y) {
      ateFood = true;
      collectSpecialFood(food, head);
      return false;
    }
    food.timer--;
    return food.timer > 0;
  });
  
  // æ£€æŸ¥é“å…·
  game.powerUps = game.powerUps.filter(powerUp => {
    if (head.x === powerUp.x && head.y === powerUp.y) {
      activatePowerUp(powerUp);
      return false;
    }
    powerUp.timer--;
    return powerUp.timer > 0;
  });
  
  // å¦‚æœæ²¡åƒåˆ°é£Ÿç‰©ï¼Œç§»é™¤å°¾å·´
  if (!ateFood) {
    game.snake.pop();
  }
  
  // ç”Ÿæˆæ–°ç‰©å“
  if (game.foods.length < DIFFICULTY_SETTINGS[game.difficulty].foodCount) {
    generateFood();
  }
  generateSpecialFood();
  generatePowerUp();
  
  // æ›´æ–°é“å…·æ•ˆæœ
  updatePowerUpEffects();
  
  // æ›´æ–°ç²’å­
  updateParticles();
  
  // çˆ±å¿ƒæ¨¡å¼é‡Œç¨‹ç¢‘
  if (game.mode === 'love') {
    checkLoveMilestones();
  }
  
  // æ£€æŸ¥å‡çº§
  checkLevelUp();
  
  // æ›´æ–°UI
  updateUI();
}

// æ£€æŸ¥çˆ±å¿ƒæ¨¡å¼é‡Œç¨‹ç¢‘
function checkLoveMilestones() {
  const milestones = [
    { score: 100, message: `è¾¾åˆ°100åˆ†ï¼è¦è¦å¥½å¼€å¿ƒï¼ğŸ’•` },
    { score: 200, message: `å¤ªå‰å®³äº†ï¼200åˆ†ï¼ğŸŒŸ` },
    { score: 500, message: `å“‡ï¼è¾¾åˆ°500åˆ†ï¼ä½ æ˜¯æœ€æ£’çš„ï¼ğŸ†` },
    { score: 1000, message: `çªç ´1000åˆ†ï¼è¦è¦æ°¸è¿œçˆ±ä½ ï¼â¤ï¸` },
    { length: 10, message: `è¦è¦å˜é•¿äº†ï¼éƒ½æ˜¯ä½ çš„åŠŸåŠ³ï¼ğŸŒ­` },
    { length: 20, message: `ä½ æŠŠè¦è¦å…»å¾—å¥½é•¿ï¼ğŸ’–` },
    { combo: 10, message: `10è¿å‡»ï¼æ“ä½œå¤ªæµç•…äº†ï¼âš¡` }
  ];
  
  milestones.forEach(milestone => {
    if (milestone.score && game.score === milestone.score) {
      showAchievement(milestone.message);
      createFloatingHearts(10);
      sounds.levelUp();
    } else if (milestone.length && game.length === milestone.length) {
      showAchievement(milestone.message);
      createFloatingHearts(8);
    } else if (milestone.combo && game.combo === milestone.combo) {
      showAchievement(milestone.message);
      createFloatingHearts(5);
    }
  });
}

function collectFood(food, position) {
  const multiplier = DIFFICULTY_SETTINGS[game.difficulty].scoreMultiplier;
  const points = Math.floor(10 * multiplier * (game.powerUpEffects.double.active ? 2 : 1));
  
  game.score += points;
  game.length++;
  
  // æ›´æ–°è¿å‡»
  const now = Date.now();
  if (now - game.lastEatTime < 2000) {
    game.combo++;
    if (game.combo > game.maxCombo) {
      game.maxCombo = game.combo;
    }
    if (game.combo > 1) {
      showCombo(game.combo);
      sounds.combo(Math.min(game.combo, 10));
    }
  } else {
    game.combo = 1;
  }
  game.lastEatTime = now;
  
  // çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šæ¶ˆæ¯
  if (game.mode === 'love' && Math.random() > 0.7) {
    const message = game.loveMessages[Math.floor(Math.random() * game.loveMessages.length)];
    showAchievement(message);
  }
  
  sounds.eat();
  createParticles(position, food.emoji, 5);
  generateFood();
}

function collectSpecialFood(food, position) {
  const multiplier = DIFFICULTY_SETTINGS[game.difficulty].scoreMultiplier;
  const points = Math.floor(food.points * multiplier * (game.powerUpEffects.double.active ? 2 : 1));
  
  game.score += points;
  game.length += 2;
  game.combo += 2;
  
  if (game.combo > game.maxCombo) {
    game.maxCombo = game.combo;
  }
  
  // çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šæ•ˆæœ
  if (game.mode === 'love') {
    createFloatingHearts(5);
    const specialMessages = [
      `å¥½å‰å®³ï¼+${points}åˆ†ï¼ğŸ’•`,
      `è¦è¦ä¸ºä½ é¼“æŒï¼ğŸ‘`,
      `ä½ æ˜¯æœ€æ£’çš„ï¼âœ¨`,
      `ç»§ç»­åŠ æ²¹ï¼â¤ï¸`
    ];
    showAchievement(specialMessages[Math.floor(Math.random() * specialMessages.length)]);
  } else {
    showAchievement(`+${points} åˆ†!`);
  }
  
  sounds.specialEat();
  createParticles(position, food.emoji, 10);
  
  setTimeout(() => generateSpecialFood(), 3000);
}

// åˆ›å»ºæ¼‚æµ®çš„çˆ±å¿ƒæ•ˆæœ
function createFloatingHearts(count) {
  for (let i = 0; i < count; i++) {
    setTimeout(() => {
      const heart = document.createElement('div');
      heart.className = 'particle';
      heart.textContent = 'ğŸ’•';
      heart.style.left = Math.random() * window.innerWidth + 'px';
      heart.style.bottom = '0px';
      heart.style.fontSize = (20 + Math.random() * 20) + 'px';
      heart.style.animation = `particle-float 3s ease-out forwards`;
      heart.style.setProperty('--dx', (Math.random() - 0.5) * 100 + 'px');
      heart.style.setProperty('--dy', '-' + (200 + Math.random() * 200) + 'px');
      document.body.appendChild(heart);
      
      setTimeout(() => heart.remove(), 3000);
    }, i * 100);
  }
}

function activatePowerUp(powerUp) {
  const duration = 5000;
  game.powerUpEffects[powerUp.type] = {
    active: true,
    endTime: Date.now() + duration
  };
  
  const messages = {
    speed: 'âš¡ æé€Ÿæ¨¡å¼ï¼',
    shield: 'ğŸ›¡ï¸ æ— æ•ŒæŠ¤ç›¾ï¼',
    slow: 'â„ï¸ æ—¶é—´å‡ç¼“ï¼',
    magnet: 'ğŸ§² ç£åŠ›å¸å¼•ï¼',
    double: 'âœ¨ åŒå€ç§¯åˆ†ï¼'
  };
  
  sounds.powerUp();
  showAchievement(messages[powerUp.type]);
  createParticles({ x: powerUp.x, y: powerUp.y }, powerUp.emoji, 8);
  updatePowerUpBar();
}

function updatePowerUpEffects() {
  const now = Date.now();
  let changed = false;
  
  Object.keys(game.powerUpEffects).forEach(effect => {
    if (game.powerUpEffects[effect].active && now > game.powerUpEffects[effect].endTime) {
      game.powerUpEffects[effect].active = false;
      changed = true;
    }
  });
  
  if (changed) {
    updatePowerUpBar();
  }
}

function checkLevelUp() {
  const newLevel = Math.floor(game.score / 100) + 1;
  if (newLevel > game.level) {
    game.level = newLevel;
    sounds.levelUp();
    
    // çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šå‡çº§æ¶ˆæ¯
    if (game.mode === 'love') {
      const messages = [
        `å‡çº§äº†ï¼å¤ªå‰å®³äº†ï¼ğŸ’•`,
        `Level ${game.level}ï¼ä½ çœŸæ£’ï¼ğŸŒŸ`,
        `ç»§ç»­åŠ æ²¹ï¼è¦è¦ç›¸ä¿¡ä½ ï¼â¤ï¸`,
        `ä½ çš„å®åŠ›åœ¨æå‡ï¼ğŸ’ª`
      ];
      showAchievement(messages[Math.floor(Math.random() * messages.length)]);
    } else {
      showAchievement(`ğŸ‰ Level ${game.level}!`);
    }
    
    // å†’é™©æ¨¡å¼ï¼šç”Ÿæˆæ–°éšœç¢ç‰©
    if (game.mode === 'adventure') {
      generateObstacles();
    }
    
    // ç”Ÿå­˜æ¨¡å¼ï¼šåŠ é€Ÿ
    if (game.mode === 'survival' && GAME_MODES[game.mode].speedIncrease) {
      game.speed = Math.max(50, game.speed - 5);
    }
  }
}

// ==================== æ¸²æŸ“ç³»ç»Ÿ ====================
function render() {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  
  // æ¸…ç©ºç”»å¸ƒ - çˆ±å¿ƒæ¨¡å¼ç‰¹æ®ŠèƒŒæ™¯
  if (game.mode === 'love') {
    const gradient = ctx.createLinearGradient(0, 0, game.canvas.width, game.canvas.height);
    gradient.addColorStop(0, '#ff6b9d');
    gradient.addColorStop(0.5, '#feca57');
    gradient.addColorStop(1, '#ff6b9d');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
    
    // ç»˜åˆ¶èƒŒæ™¯çˆ±å¿ƒ
    ctx.globalAlpha = 0.1;
    for (let i = 0; i < 5; i++) {
      const x = Math.sin(Date.now() * 0.0001 + i) * 100 + game.canvas.width / 2;
      const y = Math.cos(Date.now() * 0.0001 + i) * 100 + game.canvas.height / 2;
      ctx.font = '50px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ’•', x, y);
    }
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = '#2a2a3e';
    ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
  }
  
  // ç»˜åˆ¶ç½‘æ ¼
  drawGrid();
  
  // ç»˜åˆ¶éšœç¢ç‰©
  game.obstacles.forEach(obstacle => {
    drawObstacle(obstacle);
  });
  
  // ç»˜åˆ¶é£Ÿç‰©
  game.foods.forEach(food => {
    drawItem(food.x, food.y, food.emoji);
  });
  
  // ç»˜åˆ¶ç‰¹æ®Šé£Ÿç‰©ï¼ˆå¸¦åŠ¨ç”»ï¼‰
  game.specialFoods.forEach(food => {
    const scale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
    drawItem(food.x, food.y, food.emoji, scale);
  });
  
  // ç»˜åˆ¶é“å…·ï¼ˆå¸¦æ—‹è½¬ï¼‰
  game.powerUps.forEach(powerUp => {
    ctx.save();
    ctx.translate(
      powerUp.x * cellSize + cellSize / 2,
      powerUp.y * cellSize + cellSize / 2
    );
    ctx.rotate(Date.now() * 0.002);
    ctx.font = `${cellSize * 0.7}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(powerUp.emoji, 0, 0);
    ctx.restore();
  });
  
  // ç»˜åˆ¶è…Šè‚ ç‹—
  drawDachshund();
  
  // ç»˜åˆ¶ç²’å­
  drawParticles();
  
  // ç»˜åˆ¶æš‚åœæç¤º
  if (game.gamePaused) {
    drawPauseScreen();
  }
}

function drawGrid() {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
  ctx.lineWidth = 1;
  
  for (let i = 0; i <= GRID_SIZE; i++) {
    ctx.beginPath();
    ctx.moveTo(i * cellSize, 0);
    ctx.lineTo(i * cellSize, game.canvas.height);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, i * cellSize);
    ctx.lineTo(game.canvas.width, i * cellSize);
    ctx.stroke();
  }
}

function drawDachshund() {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  const bodyColor = game.powerUpEffects.shield.active ? '#FFD700' : '#8B4513';
  const bellyColor = game.powerUpEffects.shield.active ? '#FFA500' : '#D2691E';
  
  // ç»˜åˆ¶èº«ä½“
  game.snake.forEach((segment, index) => {
    const x = segment.x * cellSize;
    const y = segment.y * cellSize;
    const centerX = x + cellSize / 2;
    const centerY = y + cellSize / 2;
    
    if (index === 0) {
      // å¤´éƒ¨
      drawHead(centerX, centerY, cellSize, bodyColor);
    } else {
      // èº«ä½“æ®µ
      const progress = index / game.snake.length;
      const size = cellSize * (0.9 - progress * 0.2);
      
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, size * 0.5, size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // è‚šçš®
      ctx.fillStyle = bellyColor;
      ctx.beginPath();
      ctx.ellipse(centerX, centerY + 2, size * 0.35, size * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // æŠ¤ç›¾æ•ˆæœ
  if (game.powerUpEffects.shield.active) {
    drawShield();
  }
}

function drawHead(x, y, size, color) {
  const ctx = game.ctx;
  
  ctx.save();
  ctx.translate(x, y);
  
  // æ ¹æ®æ–¹å‘æ—‹è½¬
  let angle = 0;
  if (game.direction.x === 1) angle = 0;
  else if (game.direction.x === -1) angle = Math.PI;
  else if (game.direction.y === 1) angle = Math.PI / 2;
  else if (game.direction.y === -1) angle = -Math.PI / 2;
  ctx.rotate(angle);
  
  // å¤´éƒ¨
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, 0, size * 0.45, size * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // é¼»å­
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(size * 0.35, 0, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // çœ¼ç›
  const eyeY = size * 0.15;
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(size * 0.1, -eyeY, 4, 0, Math.PI * 2);
  ctx.arc(size * 0.1, eyeY, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(size * 0.12, -eyeY, 2, 0, Math.PI * 2);
  ctx.arc(size * 0.12, eyeY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // è€³æœµ
  ctx.fillStyle = '#654321';
  ctx.beginPath();
  ctx.ellipse(-size * 0.2, -size * 0.25, size * 0.15, size * 0.25, -0.3, 0, Math.PI * 2);
  ctx.ellipse(-size * 0.2, size * 0.25, size * 0.15, size * 0.25, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
}

function drawShield() {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  
  ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  
  game.snake.forEach(segment => {
    ctx.beginPath();
    ctx.arc(
      segment.x * cellSize + cellSize / 2,
      segment.y * cellSize + cellSize / 2,
      cellSize * 0.6,
      0,
      Math.PI * 2
    );
    ctx.stroke();
  });
  
  ctx.setLineDash([]);
}

function drawObstacle(obstacle) {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  const x = obstacle.x * cellSize;
  const y = obstacle.y * cellSize;
  
  ctx.fillStyle = '#555';
  ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
  
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
}

function drawItem(gridX, gridY, emoji, scale = 1) {
  const ctx = game.ctx;
  const cellSize = game.cellSize;
  
  ctx.save();
  ctx.translate(
    gridX * cellSize + cellSize / 2,
    gridY * cellSize + cellSize / 2
  );
  ctx.scale(scale, scale);
  ctx.font = `${cellSize * 0.7}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(emoji, 0, 0);
  ctx.restore();
}

function drawPauseScreen() {
  const ctx = game.ctx;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
  
  ctx.fillStyle = 'white';
  ctx.font = 'bold 30px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('æ¸¸æˆæš‚åœ', game.canvas.width / 2, game.canvas.height / 2);
  
  ctx.font = '20px Arial';
  ctx.fillText('ç‚¹å‡»ç»§ç»­', game.canvas.width / 2, game.canvas.height / 2 + 40);
}

// ==================== ç²’å­ç³»ç»Ÿ ====================
function createParticles(position, emoji, count) {
  for (let i = 0; i < count; i++) {
    game.particles.push({
      x: position.x * game.cellSize + game.cellSize / 2,
      y: position.y * game.cellSize + game.cellSize / 2,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      emoji: emoji,
      life: 1,
      decay: 0.02
    });
  }
}

function updateParticles() {
  game.particles = game.particles.filter(particle => {
    particle.x += particle.vx;
    particle.y += particle.vy;
    particle.vy += 0.1; // é‡åŠ›
    particle.life -= particle.decay;
    return particle.life > 0;
  });
}

function drawParticles() {
  const ctx = game.ctx;
  
  game.particles.forEach(particle => {
    ctx.save();
    ctx.globalAlpha = particle.life;
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(particle.emoji, particle.x, particle.y);
    ctx.restore();
  });
}

// ==================== UIæ›´æ–° ====================
function updateUI() {
  document.getElementById('score').textContent = game.score;
  document.getElementById('length').textContent = game.length;
  document.getElementById('combo').textContent = game.combo;
  document.getElementById('level').textContent = game.level;
}

function updatePowerUpBar() {
  const bar = document.getElementById('powerUpBar');
  const activeEffects = Object.entries(game.powerUpEffects)
    .filter(([_, effect]) => effect.active);
  
  if (activeEffects.length > 0) {
    bar.classList.remove('hidden');
    bar.innerHTML = activeEffects.map(([type, effect]) => {
      const remaining = Math.ceil((effect.endTime - Date.now()) / 1000);
      const icons = {
        speed: 'âš¡',
        shield: 'ğŸ›¡ï¸',
        slow: 'â„ï¸',
        magnet: 'ğŸ§²',
        double: 'âœ¨'
      };
      return `
        <div class="power-up-slot active">
          ${icons[type]}
          <div class="power-timer">${remaining}s</div>
        </div>
      `;
    }).join('');
  } else {
    bar.classList.add('hidden');
  }
}

function showCombo(combo) {
  const display = document.getElementById('comboDisplay');
  display.textContent = `${combo}x è¿å‡»!`;
  display.classList.add('show');
  
  setTimeout(() => {
    display.classList.remove('show');
  }, 500);
}

function showAchievement(text) {
  const popup = document.createElement('div');
  popup.className = 'achievement-popup';
  popup.textContent = text;
  document.body.appendChild(popup);
  
  setTimeout(() => popup.remove(), 3000);
}

function showGestureHint(direction) {
  const hint = document.getElementById('gestureHint');
  const emojis = {
    up: 'â¬†ï¸',
    down: 'â¬‡ï¸',
    left: 'â¬…ï¸',
    right: 'â¡ï¸'
  };
  
  hint.textContent = emojis[direction];
  hint.style.animation = 'none';
  setTimeout(() => {
    hint.style.animation = 'gesture-show 0.5s';
  }, 10);
}

// ==================== æ§åˆ¶ç³»ç»Ÿ ====================
function initKeyboardControls() {
  document.addEventListener('keydown', (e) => {
    if (!game.gameRunning) return;
    
    if (e.key === ' ' || e.key === 'Escape') {
      e.preventDefault();
      togglePause();
      return;
    }
    
    if (game.gamePaused) return;
    
    const key = e.key.toLowerCase();
    
    if ((key === 'arrowup' || key === 'w') && game.direction.y === 0) {
      game.nextDirection = { x: 0, y: -1 };
    } else if ((key === 'arrowdown' || key === 's') && game.direction.y === 0) {
      game.nextDirection = { x: 0, y: 1 };
    } else if ((key === 'arrowleft' || key === 'a') && game.direction.x === 0) {
      game.nextDirection = { x: -1, y: 0 };
    } else if ((key === 'arrowright' || key === 'd') && game.direction.x === 0) {
      game.nextDirection = { x: 1, y: 0 };
    }
  });
}

function initTouchControls() {
  const canvas = game.canvas;
  let touchStartX = 0;
  let touchStartY = 0;
  
  canvas.addEventListener('touchstart', (e) => {
    // åªåœ¨æ¸¸æˆè¿è¡Œæ—¶å¤„ç†è§¦æ‘¸
    if (!game.gameRunning) return;
    
    e.preventDefault();
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    game.touchStartPos = { x: touchStartX, y: touchStartY };
  });
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
  });
  
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (!game.gameRunning || !game.touchStartPos) return;
    
    const touch = e.changedTouches[0];
    const dx = touch.clientX - game.touchStartPos.x;
    const dy = touch.clientY - game.touchStartPos.y;
    
    // æœ€å°æ»‘åŠ¨è·ç¦»
    const minSwipeDistance = 30;
    
    if (Math.abs(dx) < minSwipeDistance && Math.abs(dy) < minSwipeDistance) {
      // ç‚¹å‡» - æš‚åœ
      togglePause();
      return;
    }
    
    if (game.gamePaused) return;
    
    // åˆ¤æ–­æ»‘åŠ¨æ–¹å‘
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0 && game.direction.x === 0) {
        game.nextDirection = { x: 1, y: 0 };
        showGestureHint('right');
      } else if (dx < 0 && game.direction.x === 0) {
        game.nextDirection = { x: -1, y: 0 };
        showGestureHint('left');
      }
    } else {
      if (dy > 0 && game.direction.y === 0) {
        game.nextDirection = { x: 0, y: 1 };
        showGestureHint('down');
      } else if (dy < 0 && game.direction.y === 0) {
        game.nextDirection = { x: 0, y: -1 };
        showGestureHint('up');
      }
    }
    
    game.touchStartPos = null;
  });
  
  // åŒå‡»å…¨å±
  let lastTap = 0;
  canvas.addEventListener('touchend', (e) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if (tapLength < 500 && tapLength > 0) {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.documentElement.requestFullscreen();
      }
    }
    lastTap = currentTime;
  });
}

function initVirtualControls() {
  const controls = document.querySelectorAll('.control-btn');
  
  controls.forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const dir = btn.dataset.dir;
      
      if (dir === 'pause') {
        togglePause();
        return;
      }
      
      if (!game.gameRunning || game.gamePaused) return;
      
      switch(dir) {
        case 'up':
          if (game.direction.y === 0) game.nextDirection = { x: 0, y: -1 };
          break;
        case 'down':
          if (game.direction.y === 0) game.nextDirection = { x: 0, y: 1 };
          break;
        case 'left':
          if (game.direction.x === 0) game.nextDirection = { x: -1, y: 0 };
          break;
        case 'right':
          if (game.direction.x === 0) game.nextDirection = { x: 1, y: 0 };
          break;
      }
      
      sounds.click();
    });
  });
}

function togglePause() {
  if (!game.gameRunning) return;
  game.gamePaused = !game.gamePaused;
  
  if (!game.gamePaused) {
    gameLoop();
  }
}

// ==================== æ¸¸æˆæµç¨‹ ====================
function gameLoop() {
  if (!game.gameRunning) return;
  
  updateGame();
  render();
  
  if (!game.gamePaused) {
    let speed = game.speed;
    if (game.powerUpEffects.speed.active) speed *= 0.7;
    if (game.powerUpEffects.slow.active) speed *= 1.5;
    
    setTimeout(gameLoop, speed);
  }
}

function startGame() {
  if (!game.mode) {
    alert('è¯·å…ˆé€‰æ‹©æ¸¸æˆæ¨¡å¼ï¼');
    return;
  }
  
  // çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šæ¬¢è¿
  if (game.mode === 'love') {
    showAchievement(`ğŸ’• è¦è¦ä¸ºä½ åŠ æ²¹ï¼`);
  }
  
  // æ£€æŸ¥ç‰¹æ®Šæ—¥æœŸ
  const today = new Date();
  const dateKey = `${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
  if (game.specialDates[dateKey]) {
    setTimeout(() => showAchievement(game.specialDates[dateKey]), 1000);
  }
  
  // éšè—èœå•
  document.getElementById('mainMenu').classList.add('hidden');
  
  // æ˜¾ç¤ºæ¸¸æˆå®¹å™¨
  document.querySelector('.game-wrapper').classList.add('active');
  
  // é‡æ–°è°ƒæ•´ç”»å¸ƒå¤§å°ï¼ˆç¡®ä¿åœ¨æ¸¸æˆç•Œé¢æ˜¾ç¤ºåï¼‰
  setTimeout(() => {
    resizeCanvas();
  }, 10);
  
  // è®¾ç½®æ¸¸æˆå‚æ•°
  game.difficulty = document.getElementById('difficulty').value;
  game.gameRunning = true;
  game.gamePaused = false;
  
  // åˆå§‹åŒ–å¹¶å¼€å§‹æ¸¸æˆ
  initGame();
  gameLoop();
  sounds.click();
  
  // æ‰‹æœºç«¯æ˜¾ç¤ºè™šæ‹Ÿæ§åˆ¶å™¨
  if (window.innerWidth <= 768) {
    document.getElementById('mobileControls').style.display = 'block';
  }
}

function gameOver() {
  game.gameRunning = false;
  sounds.gameOver();
  
  // éšè—è™šæ‹Ÿæ§åˆ¶å™¨
  document.getElementById('mobileControls').style.display = 'none';
  
  // ä¿å­˜é«˜åˆ†
  const modeKey = `${game.mode}_${game.difficulty}`;
  if (!game.highScores[modeKey] || game.score > game.highScores[modeKey]) {
    game.highScores[modeKey] = game.score;
    localStorage.setItem('yaoyaoHighScores', JSON.stringify(game.highScores));
    document.getElementById('newRecord').classList.remove('hidden');
  } else {
    document.getElementById('newRecord').classList.add('hidden');
  }
  
  // æ˜¾ç¤ºç»“æœ - çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šæ¶ˆæ¯
  if (game.mode === 'love') {
    document.getElementById('gameOverTitle').textContent = 
      game.score > 500 ? 'å¤ªæ£’äº†ï¼ä½ çœŸå‰å®³ï¼' : 
      game.score > 200 ? 'åšå¾—å¾ˆå¥½å“¦ï¼' : 
      'å†æ¥å†å‰ï¼';
    
    document.getElementById('gameOverMessage').textContent = 
      game.length > 20 ? 'è¦è¦è¢«ä½ çš„å®åŠ›éœ‡æ’¼äº†ï¼ğŸ’•' :
      game.length > 10 ? 'è¦è¦ä¸ºä½ æ„Ÿåˆ°éª„å‚²ï¼â¤ï¸' : 
      'è¦è¦æ°¸è¿œæ”¯æŒä½ ï¼ğŸ’–';
  } else {
    document.getElementById('gameOverTitle').textContent = 
      game.score > 500 ? 'å¤ªæ£’äº†ï¼' : 
      game.score > 200 ? 'åšå¾—ä¸é”™ï¼' : 'æ¸¸æˆç»“æŸï¼';
    
    document.getElementById('gameOverMessage').textContent = 
      game.length > 20 ? 'è¦è¦å˜æˆè¶…çº§é•¿ç‹—å•¦ï¼' :
      game.length > 10 ? 'è¦è¦åƒå¾—é¥±é¥±çš„ï¼' : 'è¦è¦è¿˜æƒ³å†åƒï¼';
  }
  
  document.getElementById('finalEmoji').textContent = 
    game.mode === 'love' ? 'ğŸ’•' :
    game.score > 500 ? 'ğŸ†' : 
    game.score > 200 ? 'ğŸŒŸ' : 'ğŸŒ­';
  
  document.getElementById('finalScore').textContent = game.score;
  document.getElementById('finalLength').textContent = game.length;
  document.getElementById('maxCombo').textContent = game.maxCombo;
  
  document.getElementById('gameOverlay').classList.remove('hidden');
}

function restartGame() {
  document.getElementById('gameOverlay').classList.add('hidden');
  game.gameRunning = true;
  initGame();
  gameLoop();
  sounds.click();
  
  // ç¡®ä¿æ¸¸æˆç•Œé¢æ˜¾ç¤º
  document.querySelector('.game-wrapper').classList.add('active');
  
  // æ‰‹æœºç«¯æ˜¾ç¤ºè™šæ‹Ÿæ§åˆ¶å™¨
  if (window.innerWidth <= 768) {
    document.getElementById('mobileControls').style.display = 'block';
  }
}

function backToMenu() {
  document.getElementById('gameOverlay').classList.add('hidden');
  document.getElementById('mainMenu').classList.remove('hidden');
  
  // éšè—æ¸¸æˆç•Œé¢
  document.querySelector('.game-wrapper').classList.remove('active');
  
  // éšè—è™šæ‹Ÿæ§åˆ¶å™¨
  document.getElementById('mobileControls').style.display = 'none';
  
  game.gameRunning = false;
  sounds.click();
}

// ==================== èœå•åŠŸèƒ½ ====================
function selectMode(mode) {
  game.mode = mode;
  
  document.querySelectorAll('.mode-card').forEach(card => {
    card.classList.remove('selected');
  });
  document.querySelector(`[data-mode="${mode}"]`).classList.add('selected');
  
  // çˆ±å¿ƒæ¨¡å¼ç‰¹æ®Šæç¤º
  if (mode === 'love') {
    const welcomeMsg = document.getElementById('welcomeMessage');
    if (welcomeMsg) {
      welcomeMsg.innerHTML = 'ğŸ’• è¿™æ˜¯ä¸“é—¨ä¸ºä½ å‡†å¤‡çš„æ¨¡å¼å“¦ï¼';
      welcomeMsg.style.color = '#ff6b9d';
    }
  } else {
    const welcomeMsg = document.getElementById('welcomeMessage');
    if (welcomeMsg) {
      welcomeMsg.innerHTML = 'é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹å†’é™©ï¼';
      welcomeMsg.style.color = '';
    }
  }
  
  sounds.click();
}

function toggleSound() {
  game.soundEnabled = !game.soundEnabled;
  document.getElementById('soundBtn').innerHTML = 
    game.soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ é™éŸ³';
  
  if (game.soundEnabled) {
    initAudio();
    sounds.click();
  }
}

function showLeaderboard() {
  const leaderboard = document.getElementById('leaderboard');
  leaderboard.classList.toggle('hidden');
  
  if (!leaderboard.classList.contains('hidden')) {
    const scores = [];
    Object.entries(game.highScores).forEach(([key, score]) => {
      const [mode, difficulty] = key.split('_');
      scores.push({
        mode: GAME_MODES[mode].name,
        difficulty: difficulty,
        score: score
      });
    });
    
    scores.sort((a, b) => b.score - a.score);
    
    leaderboard.innerHTML = '<h3>ğŸ† æ’è¡Œæ¦œ</h3>' + 
      (scores.length > 0 ? 
        scores.slice(0, 5).map((s, i) => `
          <div class="leaderboard-item">
            <span class="leaderboard-rank">#${i + 1}</span>
            <span class="leaderboard-name">${s.mode} - ${s.difficulty}</span>
            <span class="leaderboard-score">${s.score}</span>
          </div>
        `).join('') :
        '<p>è¿˜æ²¡æœ‰è®°å½•ï¼Œå¿«æ¥åˆ›é€ ç¬¬ä¸€ä¸ªå§ï¼</p>'
      );
  }
  
  sounds.click();
}

function showHelp() {
  const helpText = `
<b>ğŸ® æ¸¸æˆæ§åˆ¶</b>
${window.innerWidth > 768 ? 'â€¢ æ–¹å‘é”®æˆ–WASD' : 'â€¢ æ»‘åŠ¨å±å¹•æ§åˆ¶'}
â€¢ ç‚¹å‡»ç”»é¢æš‚åœ

<b>ğŸ– æ¸¸æˆç›®æ ‡</b>
æ§åˆ¶è¦è¦åƒé£Ÿç‰©å˜é•¿
é¿å…æ’å¢™å’Œæ’åˆ°è‡ªå·±

<b>ğŸ’• çˆ±å¿ƒæ¨¡å¼</b>
ä¸“å±çš„æµªæ¼«ä½“éªŒ
é£Ÿç‰©å˜æˆçˆ±å¿ƒç«ç‘°

<b>ğŸŒŸ é“å…·è¯´æ˜</b>
âš¡ åŠ é€Ÿ | ğŸ›¡ï¸ æŠ¤ç›¾
â„ï¸ å‡é€Ÿ | ğŸ§² ç£é“
âœ¨ åŒå€ç§¯åˆ†
  `;
  
  // åˆ›å»ºä¸€ä¸ªæ›´å¥½çš„å¸®åŠ©å¼¹çª—
  const helpDiv = document.createElement('div');
  helpDiv.className = 'menu';
  helpDiv.style.zIndex = '5000';
  helpDiv.style.maxHeight = '80vh';
  helpDiv.innerHTML = `
    <h2 style="font-size: 1.3rem; margin-bottom: 10px;">â“ æ¸¸æˆå¸®åŠ©</h2>
    <div style="text-align: left; padding: 10px; max-height: 300px; overflow-y: auto; font-size: 0.85rem;">
      ${helpText.replace(/\n/g, '<br>')}
    </div>
    <button onclick="this.parentElement.remove(); sounds.click();" style="margin-top: 10px;">æ˜ç™½äº†ï¼</button>
  `;
  document.body.appendChild(helpDiv);
  
  sounds.click();
}

function shareScore() {
  const modeName = GAME_MODES[game.mode].name;
  const text = `ğŸŒ­ è…Šè‚ ç‹—è¦è¦çš„å¤§å†’é™©\nğŸ® æ¨¡å¼ï¼š${modeName}\nğŸ† å¾—åˆ†ï¼š${game.score}åˆ†\nğŸ“ é•¿åº¦ï¼š${game.length}\nâš¡ æœ€é«˜è¿å‡»ï¼š${game.maxCombo}\n\nå¿«æ¥æŒ‘æˆ˜æˆ‘çš„è®°å½•å§ï¼`;
  
  if (navigator.share) {
    navigator.share({
      title: 'è…Šè‚ ç‹—è¦è¦çš„å¤§å†’é™©',
      text: text,
      url: window.location.href
    }).catch(err => {
      // å¦‚æœåˆ†äº«å¤±è´¥ï¼Œæ˜¾ç¤ºæ–‡æœ¬è®©ç”¨æˆ·å¤åˆ¶
      if (err.name !== 'AbortError') {
        copyToClipboard(text);
      }
    });
  } else {
    // ä¸æ”¯æŒåŸç”Ÿåˆ†äº«ï¼Œå°è¯•å¤åˆ¶åˆ°å‰ªè´´æ¿
    copyToClipboard(text);
  }
}

function copyToClipboard(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(() => {
      showAchievement('ğŸ“‹ æˆç»©å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
    }).catch(() => {
      alert(text + '\n\nï¼ˆé•¿æŒ‰å¤åˆ¶è¿™æ®µè¯åˆ†äº«ç»™æœ‹å‹å§ï¼ï¼‰');
    });
  } else {
    // é™çº§æ–¹æ¡ˆ
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand('copy');
      showAchievement('ğŸ“‹ æˆç»©å·²å¤åˆ¶ï¼');
    } catch (err) {
      alert(text + '\n\nï¼ˆé•¿æŒ‰å¤åˆ¶è¿™æ®µè¯åˆ†äº«ç»™æœ‹å‹å§ï¼ï¼‰');
    }
    document.body.removeChild(textarea);
  }
}

function loadHighScores() {
  const saved = localStorage.getItem('yaoyaoHighScores');
  if (saved) {
    game.highScores = JSON.parse(saved);
  }
}

// ==================== åˆå§‹åŒ–æ¸¸æˆ ====================
window.addEventListener('load', init);

// é˜²æ­¢æ»šåŠ¨
document.body.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive: false });

// é€‰æ‹©é»˜è®¤æ¨¡å¼
selectMode('classic');
</script>

</body>
</html>
